# Прошивка роботизированного манипулятора Rene

Код предназначен для управления четырёхзвенным манипулятором на STM32 BlackPill F411CE. Прошивка принимает JSON-команды от системы компьютерного зрения, рассчитывает углы сервоприводов и выполняет захват кубика с последующей укладкой в стакан, отвечая статусами по UART.

## Что находится в репозитории

- `platformio.ini` — профиль PlatformIO для платы STM32 BlackPill F411CE: выбор фреймворка Arduino, скорость монитора, загрузка через DFU и зависимость ArduinoJson.【F:platformio.ini†L11-L20】
- `include/` — заголовочные файлы проекта (например, `config.h`, `comun.h`, `mathCalc.h`, `movementServo.h`) подключаются отсюда при сборке.
- `src/` — основная логика прошивки:
  - `main.cpp` — точка входа, настройка OCServo, запуск конечного автомата для последовательности движений, обработка JSON-команд и отправка статусов в UART.【F:src/main.cpp†L87-L415】
  - `config.cpp` / `config.h` — общие константы: ID сервоприводов, пины UART/LED/кнопки, базовые углы и глобальные переменные целей для каждого привода.【F:src/config.h†L17-L76】【F:src/config.cpp†L3-L25】
  - `comun.cpp` / `comun.h` — приём построчных JSON из UART и разбор полей команды (`status`, `target`, координаты для кубика и стакана) в структуру `OPI_command`. Проверяет валидность координат через `checkOPI`.【F:src/comun.cpp†L12-L56】【F:src/comun.h†L7-L29】
  - `mathCalc.cpp` / `mathCalc.h` — обратная кинематика: преобразование XYZ-координат в углы сервоприводов, базовая проверка диапазонов и контроль высоты над базой манипулятора.【F:src/mathCalc.cpp†L90-L169】【F:src/mathCalc.h†L4-L12】
  - `movementServo.cpp` / `movementServo.h` — вспомогательные функции для задания целевых углов, поэтапного вращения каждого привода и управления захватом (отдельный привод «grip»).【F:src/movementServo.cpp†L6-L31】【F:src/movementServo.h†L4-L9】
- `lib/` — вложенная библиотека OCServo, используемая для управления сервоприводами.
- `test/` — заготовки для тестов PlatformIO (по умолчанию пустые).

## Как работает прошивка

1. **Инициализация**: в `main.cpp` настраиваются Serial-порты, сервоприводы получают базовые углы и параметры крутящего момента, считывается состояние кнопки калибровки и светодиоды показывают готовность.【F:src/main.cpp†L9-L175】
2. **Приём команд**: `readOPI` получает строку JSON из `OPI_UART`, `deserializeJson` извлекает координаты кубика и стакана, а `checkOPI` гарантирует, что все координаты заданы и являются числами.【F:src/comun.cpp†L12-L56】
3. **Кинематика**: `calculateAngles` вычисляет углы плеча, локтя и предплечья для заданной точки в пространстве, проверяет длины звеньев и допустимость высоты.【F:src/mathCalc.cpp†L90-L169】
4. **Движение**: конечный автомат `loop()` проходит состояния (`to_cube`, `grip_close`, `lift`, `to_cup`, `release`, `finish`). На каждом шаге вызываются `setTarget*` из `movementServo.cpp`, затем сервы покадрово двигаются к целям через `loopAngle`/`loopGripper`. Статус каждого этапа отправляется в UART как JSON.【F:src/main.cpp†L219-L415】
5. **Захват**: функции `gripClose` и `gripOpen` управляют четвёртым сервоприводом для фиксации и отпускания объекта при подходе к кубику и над стаканом.【F:src/main.cpp†L235-L245】【F:src/main.cpp†L359-L405】
6. **Калибровка**: при нажатии кнопки (`PB5`) в начале работы выполняется процедура установки нулевых позиций, индицируемая светодиодами на `PB6`, `PB7`, `PB4`. Базовые углы сохраняются в глобальных переменных из `config.h`.【F:src/main.cpp†L33-L85】【F:src/config.h†L53-L76】

## Статусы и обмен данными

- **Входящие**: система зрения присылает JSON со статусом `200`, полем `"target": "dual"` и двумя объектами координат: `block_position` и `cup_position` (`x`, `y`, `z`, `Ry`). Ожидается построчная передача по UART `OPI_UART` (пины `PA3`/`PA2`).【F:src/config.cpp†L14-L25】【F:src/comun.cpp†L30-L56】
- **Исходящие**: прошивка отвечает сообщениями вида `{ "robot_status": "moving_to_cube" }`, отражая текущее состояние автомата; финальный статус — `finish`. Сообщения отправляются из `loop()` после смены этапа движения.【F:src/main.cpp†L235-L415】

## Ключевые константы

- **Геометрия звеньев**: длины плеча и локтя (`SHOULDER_LENGTH`, `ELBOW_LENGTH`), базовая высота `BASE_HEIGHT` и корректировки по осям лежат в `config.h`. Они используются при расчётах в `mathCalc.cpp`.【F:src/config.h†L66-L76】【F:src/mathCalc.cpp†L90-L140】
- **Сервоприводы**: идентификаторы `SHOULDER_SERVO_ID`, `ELBOW_SERVO_ID`, `FOREARM_SERVO_ID`, `GRIPPER_SERVO_ID` задаются в `config.h`; направление вращения и стартовые углы определены в том же файле и применяются при инициализации в `main.cpp`.【F:src/config.h†L17-L52】【F:src/main.cpp†L96-L175】
- **Коммуникация**: UART для системы зрения (`OPI_UART`) и для сервоприводов (`SERVO_SERIAL`) настраиваются в `config.cpp` и `main.cpp` с фиксированной скоростью 115200 бод и тайм-аутами на чтение. Пины и частота указаны в `config.h`.【F:src/config.h†L19-L52】【F:src/config.cpp†L3-L13】

## Быстрые подсказки по навигации по коду

- Алгоритм движения и статусы — `src/main.cpp` (раздел `loop()` и вспомогательные функции).
- Разбор входящих JSON — `src/comun.cpp` (`readOPI`, `deserializeJson`, `checkOPI`).
- Обратная кинематика — `src/mathCalc.cpp` (`calculateAngles`, `getAngles`).
- Низкоуровневое управление сервами — `src/movementServo.cpp` (`setTarget*`, `loopAngle`, `loopGripper`).
- Константы пинов, длины звеньев, идентификаторы сервоприводов — `src/config.h` / `src/config.cpp`.
